# Script that generates the alphabet.h file that is used to provide a 
#   representation of characters for the light wand to display

from pathlib import Path
from PIL import Image, ImageFont, ImageDraw
import numpy as np
import argparse

SOURCE_DIR = Path("./alphabet_source")
CHAR_WIDTH = 15
CHAR_HEIGHT = 15

ALPHABET = {
    'A': 'A',
    'B': 'B',
    'C': 'C',
    'D': 'D',
    'E': 'E',
    'F': 'F',
    'G': 'G',
    'H': 'H',
    'I': 'I',
    'J': 'J',
    'K': 'K',
    'L': 'L',
    'M': 'M',
    'N': 'N',
    'O': 'O',
    'P': 'P',
    'Q': 'Q',
    'R': 'R',
    'S': 'S',
    'T': 'T',
    'U': 'U',
    'V': 'V',
    'W': 'W',
    'X': 'X',
    'Y': 'Y',
    'Z': 'Z',
    'BANG': '!',
    'QUESTION': '?',
    'PERIOD': '.',
    'COMMA': ',',
}

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('font_path', type=Path, help="Path to the true type font (.tff) font to generate the light wand font from")
    parser.add_argument('xoff', type=int, help="Character offset in X direction")
    parser.add_argument('yoff', type=int, help="Character offset in Y direction")
    parser.add_argument('font_size', type=int, help="Character font size")
    parser.add_argument('--show', action='store_true', help="If set, this flag causes each character image to be shown during generation")

    args = parser.parse_args()

    print("Generating alphabet...")

    generated_c = """
/*
Generated by scripts/generate_alphabet.py

This h file contains generated representations for characters to be dispalyed on the light wand as arrays of 32-bit integers
Each 32-bit integer in an array is a column of the characer, and each bit in that integer is a pixel. 1's mean on, 0's mean off.

The lowest pixel on the wand is the LSB

*/

"""
    generated_c += "#include <stdint.h>\n\n"
    generated_c += f"#define\tCHAR_WIDTH\t{CHAR_WIDTH}\n#define\tCHAR_HEIGHT\t{CHAR_HEIGHT}\n\n"

    for char_name in list(ALPHABET.keys()):
        image = Image.new('L', size=(CHAR_WIDTH, CHAR_HEIGHT))
        draw = ImageDraw.Draw(image)

        font = ImageFont.truetype(str(args.font_path), args.font_size)
        draw.text((args.xoff, args.yoff), ALPHABET[char_name], font=font, fill=255)

        print(args.show)
        if args.show:
            image.show()

        # convert the image to a grayscale array of ones and zeroes.
        imarray = np.asarray(image) / 255
        imarray = np.around(imarray, decimals=0)
        inverter = np.ones_like(imarray)
        imarray = inverter - imarray

        print(imarray)
            
        # now extract the vertical columns of the image and turn them into 32-bit bitfields
        integers = np.zeros(CHAR_WIDTH, dtype="uint32")
        for col in range(CHAR_WIDTH):
            column = imarray[:, col]

            for i, bit in enumerate(column):
                integers[col] = integers[col] | ((not int(bit)) << i)

        generated_c += f"const uint32_t CHAR_{char_name}[CHAR_WIDTH]\t= "
        generated_c += "{"
        for i in integers:
            generated_c += f"0x{i:08x},"

        generated_c = generated_c[:-1]
        generated_c = generated_c + "};\n"

    print("Copy and paste the following code into alphabet.h:")
    print()
    print(generated_c)